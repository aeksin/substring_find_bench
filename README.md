# Бенчмарк для алгоритма поиска всех вхождений подстроки в строке
Проект предназначен для измерения времени работы алгоритма поиска подстроки в строке(в основном там, где не используются встроенные возможности языка Python, реализован алгоритм Кнута — Морриса — Пратта)  
Написано на C, GNU Assembly и Python, запускается через Python с помощью модуля ctypes
## Требования  
Требованиями для запуска проекта являются любая unix-подобная система на процессоре x86-64.  
По умолчанию динамическая библиотека(libasm.so)  с функциями из С и ассемблера собрана и лежит в репозитории. При необходимости сборки динамической библиотеки необходимо поставить make и средства сборки gnu:  
    ```
    apt -y install build-essential
    ```   
    ```
    apt install make
    ```
## Описание проекта
В качестве примера задачи, которую можно оптимизировать на ассемблере, была выбрана задача поиска всех вхождений подстроки в определённую строку. На Python был написан алгоритм Кнута-Морриса-Пратта, решение через find и решение через re.finditer. На си и на ассемблере был написан всё тот же алгоритм Кнута-Морриса-Пратта в двух версиях - где строки складываются на питоне а затем передаются в алгоритм, и разбитый на две части алгоритм без сложения строк. Стоит отметить, что в случае, когда строка является короткой или число вхождений подстроки в строку сравнительно мало, рекордсменом является пайтоновский find, так как он реализует другой алгоритм, и ему, в отличие от си и ассемблера, не нужно тратить время на конвертацию из пайтоновских строки в на байтовую строку. Но данный метод очень сильно замедляется, когда строка становится большой длины и число вхождений подстроки в строку также сравнительно велико(~100-1000 и более). Связка пайтона с ассемблером через ctypes была выбрана потому, что:  
во-первых, ctypes является встроенным модулем для python, не требующим дополнительной установки  
во-вторых, в отличие от С/Python API, в нем легче и проще конвертировать типы из пайтоновских в простые си-шные типы
## результат работы
![https://github.com/aeksin/substring_find_bench/raw/main/substring_file_bench/results.png](https://github.com/aeksin/substring_find_bench/blob/main/results.png)
## Выводы и общие мысли
В самом начале захотел проверить, можно ли оптимизировать что-то простое - арифметические операции, какие-нибудь функции из math. В итоге, конвертация типов в простые работала дольше, чем питон считал арифметические операции.  
Дальше я захотел проверить то, что на интуитивном уровне должно работать медленнее всего - цикл for. в качестве примера я в цикле из 10 миллиардов итераций в питоне и в ассемблере прибавлял единицу. в итоге - ассемблер сработал быстрее питона приблизительно в 36 раз. В итоге я пришел к тому, что нужно оптимизировать что-то с циклами, но что нельзя выполнить просто вызовом метода или функции. Относительно встроенных возможностей Python - find работает очень быстро, если в строке содержится одна подстрока, то он работал быстрее оптимизированного алгоритма на асме где-то в 1.5 раза, хотя я в подсчёт для асма включаю конвертацию в байтовую строку из питона, которая занимает где-то половину времени. Если же в строке много таких подстрок, то из-за циклов этот способ начинает работать гораздо медленнее. Использование re.finditer, напротив, при большом числе подстрок работает лучше, чем find, но при большой длине подстрок скорость падает крайне значительно, то есть при подстроке размером в 10 миллионов символов на строке той же длины, что в примере, скорость падает с 8 до 150 секунд. 
### Интересный факт
Ещё из интересных моментов, если из питона с помощью ctypes выделить память под сишные массивы, то с помощью подсчёта ссылок питон сам освободит память, поэтому вызов си/ассемблера из питона при выделении памяти в питоне является оригинальным способом использовать умные указатели и не очищать память в ручную.
## Итого:
В результате проделанной работы можно сделать следующие выводы:  
1) Если необходимо найти одно вхождение подстроки, лучше использовать find()  
2) Если необходимо найти несколько вхождений подстроки, целевая строка малой длины или сами подстроки небольшой длины, лучше использовать re.iterfinder()  
3) Если строка большой длины или число подстрок велико, ассемблерная функция обладает наиболее высокой скоростью работы
